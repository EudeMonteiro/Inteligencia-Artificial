import numpy as np
import random
import itertools
import collections
import time

class Node:
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance
    - 'parent' is the preceding node generated by the solver, if any
    - 'action' is the action taken to produce puzzle, if any
    """
    def __init__(self, puzzle, parent=None, action=None):
        self.puzzle = puzzle
        self.parent = parent
        self.action = action

        if action is None:
          self.action = "Z"
       
 
    @property
    def state(self):
        """
        Return a hashable representation of self
        """
        return str(self)

    @property 
    def path(self):
        """
        Recupera o caminho do estado atual até o inicial'
        """
        node, caminho = self, []
        while node:
            caminho.append(node)
            node = node.parent
        yield from reversed(caminho)

    @property
    def solved(self):
        """ Wrapper to check if 'puzzle' is solved """
        return self.puzzle.solved

    @property
    def actions(self):
        """ Wrapper for 'actions' accessible at current state """
        return self.puzzle.actions

    def __str__(self):
        return str(self.puzzle)


class Solver():
    
    def __init__(self, start):
      self.start = start
    
    def solve(self, search):
        """
        Realiza busca em largura ou em profundidade
        """
        
        borda = collections.deque([Node(self.start)])
        explorado = set()
        explorado.add(borda[0].state)
        
        print("\nOrdem de visita:\n")
        
        #Busca em largura
        if search == 'largura':

          while borda:
              borda = collections.deque(list(borda))
              node = borda.popleft()
              print(*(node.puzzle.board), sep="\n")
              print()
                                        
              if node.solved:
                  return node.path

              for move, action in sorted(node.actions, key=lambda x: x[1]):
                  adjacente = Node(move(), node, action)

                  if adjacente.state not in explorado:
                      borda.append(adjacente)
                      explorado.add(adjacente.state)

        
        #Busca em profundidade
        elif search == 'profundidade':
          
          while borda:
            borda = collections.deque(list(borda))
            node = borda.pop()
            print(*(node.puzzle.board), sep="\n")
            print()
           
            if node.solved:
                return node.path          

            for move, action in sorted(node.actions, key=lambda x: x[1], reverse=True):
                adjacente = Node(move(), node, action)

                if adjacente.state not in explorado:
                    borda.append(adjacente)
                    explorado.add(adjacente.state)



class Puzzle:
    """
    A class representing an '8-puzzle'.
    - 'board' should be a square list of lists with integer entries 0...width^2 - 1
       e.g. [[1,2,3],[4,0,6],[7,5,8]]
    """
    def __init__(self, board):
        self.width = len(board[0])
        self.board = board

    @property
    def solved(self):
        """
        
        O quebra-cabeça é resolvido se, para toda linha, coluna e diagonal
        da tabela, os números que as compõem somam 15. Assim, um estado
        objetivo é identificado caso a concatenação de uma lista contendo
        estas somas tenha apenas um único elemento e ele seja igual a 15.
        """
        
        estado = np.array(self.board)

        diagonais = np.array(np.concatenate([[estado.trace()] * self.width,
                                            [estado[::-1].trace()] * self.width]))

        somas = np.concatenate([estado.sum(axis=0), 
                                estado.sum(axis=1),
                                diagonais])
        
        x = np.unique(somas)
        
        return (len(x) == 1) and (x[0] == 15)

        
    @property 
    def actions(self):
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'action'.
        """
        def create_move(at, to):
            return lambda: self._move(at, to)

        moves = []
        for i, j in itertools.product(range(self.width),
                                      range(self.width)):
            
            direcoes = {'1 Cima':    (i+1, j),
                        '2 Baixo':   (i-1, j),
                        '3 Esquerda':(i, j+1),
                        '4 Direita': (i, j-1)}

            for action, (r, c) in direcoes.items():
                if r >= 0 and c >= 0 and r < self.width and c < self.width and \
                   self.board[r][c] == 9:
                    
                    move = create_move((i,j), (r,c)), action
                    moves.append(move)
        return moves


    def copy(self):
        """
        Return a new puzzle with the same board as 'self'
        """
        board = []
        for row in self.board:
            board.append([x for x in row])
        return Puzzle(board)

    def _move(self, at, to):
        """
        Return a new puzzle where 'at' and 'to' tiles have been swapped.
        NOTE: all moves should be 'actions' that have been executed
        """
        copy = self.copy()
        i, j = at
        r, c = to
        copy.board[i][j], copy.board[r][c] = copy.board[r][c], copy.board[i][j]
        return copy

    def pprint(self):
        for row in self.board:
            print(row)
        print()

    def __str__(self):
        return ''.join(map(str, self))

    def __iter__(self):
        for row in self.board:
            yield from row


     
def driver(board: int, search: str, show: bool = None):
  puzzle = Puzzle(board)

  s = Solver(puzzle)
  t_inicial = time.perf_counter()
  p = s.solve(search)
  t_final = time.perf_counter()

  tempo_execucao = t_final - t_inicial
  steps = 0

  if show:
    for node in p:
        if node.action == 'Z':
          print("Estado Inicial")
        else:
          print(node.action[2:])

        node.puzzle.pprint()
        steps += 1

    print("Comprimento do caminho até o objetivo: " + str(steps))
    print(f"Tempo de execução total: {tempo_execucao} segundos")

  return steps, tempo_execucao


if __name__ == '__main__':
  
  estado_inicial = [[6,9,8],
                    [7,1,3],
                    [2,5,4]]

  driver(estado_inicial, 'largura', True)  
  driver(estado_inicial, 'profundidade', True)
